{"version":3,"file":"@restart-DNSoxZk-.js","sources":["../../node_modules/@restart/hooks/esm/useCommittedRef.js","../../node_modules/@restart/hooks/esm/useEventCallback.js","../../node_modules/@restart/hooks/esm/useCallbackRef.js","../../node_modules/@restart/hooks/esm/useMounted.js","../../node_modules/@restart/hooks/esm/useSafeState.js","../../node_modules/@restart/hooks/esm/useMergedRefs.js"],"sourcesContent":["import { useEffect, useRef } from 'react';\n\n/**\n * Creates a `Ref` whose value is updated in an effect, ensuring the most recent\n * value is the one rendered with. Generally only required for Concurrent mode usage\n * where previous work in `render()` may be discarded before being used.\n *\n * This is safe to access in an event handler.\n *\n * @param value The `Ref` value\n */\nfunction useCommittedRef(value) {\n  const ref = useRef(value);\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref;\n}\nexport default useCommittedRef;","import { useCallback } from 'react';\nimport useCommittedRef from './useCommittedRef';\nexport default function useEventCallback(fn) {\n  const ref = useCommittedRef(fn);\n  return useCallback(function (...args) {\n    return ref.current && ref.current(...args);\n  }, [ref]);\n}","import { useState } from 'react';\n\n/**\n * A convenience hook around `useState` designed to be paired with\n * the component [callback ref](https://reactjs.org/docs/refs-and-the-dom.html#callback-refs) api.\n * Callback refs are useful over `useRef()` when you need to respond to the ref being set\n * instead of lazily accessing it in an effect.\n *\n * ```ts\n * const [element, attachRef] = useCallbackRef<HTMLDivElement>()\n *\n * useEffect(() => {\n *   if (!element) return\n *\n *   const calendar = new FullCalendar.Calendar(element)\n *\n *   return () => {\n *     calendar.destroy()\n *   }\n * }, [element])\n *\n * return <div ref={attachRef} />\n * ```\n *\n * @category refs\n */\nexport default function useCallbackRef() {\n  return useState(null);\n}","import { useRef, useEffect } from 'react';\n\n/**\n * Track whether a component is current mounted. Generally less preferable than\n * properlly canceling effects so they don't run after a component is unmounted,\n * but helpful in cases where that isn't feasible, such as a `Promise` resolution.\n *\n * @returns a function that returns the current isMounted state of the component\n *\n * ```ts\n * const [data, setData] = useState(null)\n * const isMounted = useMounted()\n *\n * useEffect(() => {\n *   fetchdata().then((newData) => {\n *      if (isMounted()) {\n *        setData(newData);\n *      }\n *   })\n * })\n * ```\n */\nexport default function useMounted() {\n  const mounted = useRef(true);\n  const isMounted = useRef(() => mounted.current);\n  useEffect(() => {\n    mounted.current = true;\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n  return isMounted.current;\n}","import { useCallback } from 'react';\nimport useMounted from './useMounted';\n\n/**\n * `useSafeState` takes the return value of a `useState` hook and wraps the\n * setter to prevent updates onces the component has unmounted. Can used\n * with `useMergeState` and `useStateAsync` as well\n *\n * @param state The return value of a useStateHook\n *\n * ```ts\n * const [show, setShow] = useSafeState(useState(true));\n * ```\n */\n\nfunction useSafeState(state) {\n  const isMounted = useMounted();\n  return [state[0], useCallback(nextState => {\n    if (!isMounted()) return;\n    return state[1](nextState);\n  }, [isMounted, state[1]])];\n}\nexport default useSafeState;","import { useMemo } from 'react';\nconst toFnRef = ref => !ref || typeof ref === 'function' ? ref : value => {\n  ref.current = value;\n};\nexport function mergeRefs(refA, refB) {\n  const a = toFnRef(refA);\n  const b = toFnRef(refB);\n  return value => {\n    if (a) a(value);\n    if (b) b(value);\n  };\n}\n\n/**\n * Create and returns a single callback ref composed from two other Refs.\n *\n * ```tsx\n * const Button = React.forwardRef((props, ref) => {\n *   const [element, attachRef] = useCallbackRef<HTMLButtonElement>();\n *   const mergedRef = useMergedRefs(ref, attachRef);\n *\n *   return <button ref={mergedRef} {...props}/>\n * })\n * ```\n *\n * @param refA A Callback or mutable Ref\n * @param refB A Callback or mutable Ref\n * @category refs\n */\nfunction useMergedRefs(refA, refB) {\n  return useMemo(() => mergeRefs(refA, refB), [refA, refB]);\n}\nexport default useMergedRefs;"],"names":["useCommittedRef","value","ref","useRef","useEffect","useEventCallback","fn","useCallback","args","useCallbackRef","useState","useMounted","mounted","isMounted","useSafeState","state","nextState","toFnRef","mergeRefs","refA","refB","a","b","useMergedRefs","useMemo"],"mappings":"wCAWA,SAASA,EAAgBC,EAAO,CAC9B,MAAMC,EAAMC,EAAM,OAACF,CAAK,EACxBG,OAAAA,EAAAA,UAAU,IAAM,CACdF,EAAI,QAAUD,CAClB,EAAK,CAACA,CAAK,CAAC,EACHC,CACT,CCfe,SAASG,EAAiBC,EAAI,CAC3C,MAAMJ,EAAMF,EAAgBM,CAAE,EAC9B,OAAOC,EAAW,YAAC,YAAaC,EAAM,CACpC,OAAON,EAAI,SAAWA,EAAI,QAAQ,GAAGM,CAAI,CAC7C,EAAK,CAACN,CAAG,CAAC,CACV,CCmBe,SAASO,GAAiB,CACvC,OAAOC,EAAAA,SAAS,IAAI,CACtB,CCNe,SAASC,GAAa,CACnC,MAAMC,EAAUT,EAAM,OAAC,EAAI,EACrBU,EAAYV,EAAAA,OAAO,IAAMS,EAAQ,OAAO,EAC9CR,OAAAA,EAAAA,UAAU,KACRQ,EAAQ,QAAU,GACX,IAAM,CACXA,EAAQ,QAAU,EACnB,GACA,EAAE,EACEC,EAAU,OACnB,CCjBA,SAASC,EAAaC,EAAO,CAC3B,MAAMF,EAAYF,EAAY,EAC9B,MAAO,CAACI,EAAM,CAAC,EAAGR,EAAAA,YAAYS,GAAa,CACzC,GAAKH,EAAS,EACd,OAAOE,EAAM,CAAC,EAAEC,CAAS,CAC1B,EAAE,CAACH,EAAWE,EAAM,CAAC,CAAC,CAAC,CAAC,CAC3B,CCpBA,MAAME,EAAUf,GAAO,CAACA,GAAO,OAAOA,GAAQ,WAAaA,EAAMD,GAAS,CACxEC,EAAI,QAAUD,CAChB,EACO,SAASiB,EAAUC,EAAMC,EAAM,CACpC,MAAMC,EAAIJ,EAAQE,CAAI,EAChBG,EAAIL,EAAQG,CAAI,EACtB,OAAOnB,GAAS,CACVoB,GAAGA,EAAEpB,CAAK,EACVqB,GAAGA,EAAErB,CAAK,CACf,CACH,CAkBA,SAASsB,EAAcJ,EAAMC,EAAM,CACjC,OAAOI,EAAO,QAAC,IAAMN,EAAUC,EAAMC,CAAI,EAAG,CAACD,EAAMC,CAAI,CAAC,CAC1D","x_google_ignoreList":[0,1,2,3,4,5]}