{"version":3,"file":"chess.js-D61LfqgS.js","sources":["../../node_modules/chess.js/dist/esm/chess.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\nexport const WHITE = 'w';\nexport const BLACK = 'b';\nexport const PAWN = 'p';\nexport const KNIGHT = 'n';\nexport const BISHOP = 'b';\nexport const ROOK = 'r';\nexport const QUEEN = 'q';\nexport const KING = 'k';\nexport const DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nconst EMPTY = -1;\nconst FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q',\n};\n// prettier-ignore\nexport const SQUARES = [\n    'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n    'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n    'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n    'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n    'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n    'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n    'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n    'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n];\nconst BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64,\n};\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88 = {\n    a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\n    a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\n    a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\n    a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\n    a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\n    a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\n    a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n};\nconst PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15],\n};\nconst PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1],\n};\n// prettier-ignore\nconst ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\n];\n// prettier-ignore\nconst RAYS = [\n    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\n    0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\n    0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\n    0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\n    0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\n    1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\n    0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\n    0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\n    0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\n    0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\n    -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\n];\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 };\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [KNIGHT, BISHOP, ROOK, QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst SIDES = {\n    [KING]: BITS.KSIDE_CASTLE,\n    [QUEEN]: BITS.QSIDE_CASTLE,\n};\nconst ROOKS = {\n    w: [\n        { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n    ],\n    b: [\n        { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n    ],\n};\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 };\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square) {\n    return square >> 4;\n}\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square) {\n    return square & 0xf;\n}\nfunction isDigit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n}\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square) {\n    const f = file(square);\n    const r = rank(square);\n    return ('abcdefgh'.substring(f, f + 1) +\n        '87654321'.substring(r, r + 1));\n}\nfunction swapColor(color) {\n    return color === WHITE ? BLACK : WHITE;\n}\nexport function validateFen(fen) {\n    // 1st criterion: 6 space-seperated fields?\n    const tokens = fen.split(/\\s+/);\n    if (tokens.length !== 6) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: must contain six space-delimited fields',\n        };\n    }\n    // 2nd criterion: move number field is a integer value > 0?\n    const moveNumber = parseInt(tokens[5], 10);\n    if (isNaN(moveNumber) || moveNumber <= 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: move number must be a positive integer',\n        };\n    }\n    // 3rd criterion: half move counter is an integer >= 0?\n    const halfMoves = parseInt(tokens[4], 10);\n    if (isNaN(halfMoves) || halfMoves < 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: half move counter number must be a non-negative integer',\n        };\n    }\n    // 4th criterion: 4th field is a valid e.p.-string?\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n        return { ok: false, error: 'Invalid FEN: en-passant square is invalid' };\n    }\n    // 5th criterion: 3th field is a valid castle-string?\n    if (/[^kKqQ-]/.test(tokens[2])) {\n        return { ok: false, error: 'Invalid FEN: castling availability is invalid' };\n    }\n    // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n    if (!/^(w|b)$/.test(tokens[1])) {\n        return { ok: false, error: 'Invalid FEN: side-to-move is invalid' };\n    }\n    // 7th criterion: 1st field contains 8 rows?\n    const rows = tokens[0].split('/');\n    if (rows.length !== 8) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n        };\n    }\n    // 8th criterion: every row is valid?\n    for (let i = 0; i < rows.length; i++) {\n        // check for right sum of fields AND not two numbers in succession\n        let sumFields = 0;\n        let previousWasNumber = false;\n        for (let k = 0; k < rows[i].length; k++) {\n            if (isDigit(rows[i][k])) {\n                if (previousWasNumber) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (consecutive number)',\n                    };\n                }\n                sumFields += parseInt(rows[i][k], 10);\n                previousWasNumber = true;\n            }\n            else {\n                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (invalid piece)',\n                    };\n                }\n                sumFields += 1;\n                previousWasNumber = false;\n            }\n        }\n        if (sumFields !== 8) {\n            return {\n                ok: false,\n                error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n            };\n        }\n    }\n    // 9th criterion: is en-passant square legal?\n    if ((tokens[3][1] == '3' && tokens[1] == 'w') ||\n        (tokens[3][1] == '6' && tokens[1] == 'b')) {\n        return { ok: false, error: 'Invalid FEN: illegal en-passant square' };\n    }\n    // 10th criterion: does chess position contain exact two kings?\n    const kings = [\n        { color: 'white', regex: /K/g },\n        { color: 'black', regex: /k/g },\n    ];\n    for (const { color, regex } of kings) {\n        if (!regex.test(tokens[0])) {\n            return { ok: false, error: `Invalid FEN: missing ${color} king` };\n        }\n        if ((tokens[0].match(regex) || []).length > 1) {\n            return { ok: false, error: `Invalid FEN: too many ${color} kings` };\n        }\n    }\n    // 11th criterion: are any pawns on the first or eighth rows?\n    if (Array.from(rows[0] + rows[7]).some((char) => char.toUpperCase() === 'P')) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: some pawns are on the edge rows',\n        };\n    }\n    return { ok: true };\n}\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move, moves) {\n    const from = move.from;\n    const to = move.to;\n    const piece = move.piece;\n    let ambiguities = 0;\n    let sameRank = 0;\n    let sameFile = 0;\n    for (let i = 0, len = moves.length; i < len; i++) {\n        const ambigFrom = moves[i].from;\n        const ambigTo = moves[i].to;\n        const ambigPiece = moves[i].piece;\n        /*\n         * if a move of the same piece type ends on the same to square, we'll need\n         * to add a disambiguator to the algebraic notation\n         */\n        if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n            ambiguities++;\n            if (rank(from) === rank(ambigFrom)) {\n                sameRank++;\n            }\n            if (file(from) === file(ambigFrom)) {\n                sameFile++;\n            }\n        }\n    }\n    if (ambiguities > 0) {\n        if (sameRank > 0 && sameFile > 0) {\n            /*\n             * if there exists a similar moving piece on the same rank and file as\n             * the move in question, use the square as the disambiguator\n             */\n            return algebraic(from);\n        }\n        else if (sameFile > 0) {\n            /*\n             * if the moving piece rests on the same file, use the rank symbol as the\n             * disambiguator\n             */\n            return algebraic(from).charAt(1);\n        }\n        else {\n            // else use the file symbol\n            return algebraic(from).charAt(0);\n        }\n    }\n    return '';\n}\nfunction addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {\n    const r = rank(to);\n    if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n        for (let i = 0; i < PROMOTIONS.length; i++) {\n            const promotion = PROMOTIONS[i];\n            moves.push({\n                color,\n                from,\n                to,\n                piece,\n                captured,\n                promotion,\n                flags: flags | BITS.PROMOTION,\n            });\n        }\n    }\n    else {\n        moves.push({\n            color,\n            from,\n            to,\n            piece,\n            captured,\n            flags,\n        });\n    }\n}\nfunction inferPieceType(san) {\n    let pieceType = san.charAt(0);\n    if (pieceType >= 'a' && pieceType <= 'h') {\n        const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n        if (matches) {\n            return undefined;\n        }\n        return PAWN;\n    }\n    pieceType = pieceType.toLowerCase();\n    if (pieceType === 'o') {\n        return KING;\n    }\n    return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nfunction trimFen(fen) {\n    /*\n     * remove last two fields in FEN string as they're not needed when checking\n     * for repetition\n     */\n    return fen.split(' ').slice(0, 4).join(' ');\n}\nexport class Chess {\n    _board = new Array(128);\n    _turn = WHITE;\n    _header = {};\n    _kings = { w: EMPTY, b: EMPTY };\n    _epSquare = -1;\n    _halfMoves = 0;\n    _moveNumber = 0;\n    _history = [];\n    _comments = {};\n    _castling = { w: 0, b: 0 };\n    // tracks number of times a position has been seen for repetition checking\n    _positionCount = {};\n    constructor(fen = DEFAULT_POSITION) {\n        this.load(fen);\n    }\n    clear({ preserveHeaders = false } = {}) {\n        this._board = new Array(128);\n        this._kings = { w: EMPTY, b: EMPTY };\n        this._turn = WHITE;\n        this._castling = { w: 0, b: 0 };\n        this._epSquare = EMPTY;\n        this._halfMoves = 0;\n        this._moveNumber = 1;\n        this._history = [];\n        this._comments = {};\n        this._header = preserveHeaders ? this._header : {};\n        this._positionCount = {};\n        /*\n         * Delete the SetUp and FEN headers (if preserved), the board is empty and\n         * these headers don't make sense in this state. They'll get added later\n         * via .load() or .put()\n         */\n        delete this._header['SetUp'];\n        delete this._header['FEN'];\n    }\n    removeHeader(key) {\n        if (key in this._header) {\n            delete this._header[key];\n        }\n    }\n    load(fen, { skipValidation = false, preserveHeaders = false } = {}) {\n        let tokens = fen.split(/\\s+/);\n        // append commonly omitted fen tokens\n        if (tokens.length >= 2 && tokens.length < 6) {\n            const adjustments = ['-', '-', '0', '1'];\n            fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');\n        }\n        tokens = fen.split(/\\s+/);\n        if (!skipValidation) {\n            const { ok, error } = validateFen(fen);\n            if (!ok) {\n                throw new Error(error);\n            }\n        }\n        const position = tokens[0];\n        let square = 0;\n        this.clear({ preserveHeaders });\n        for (let i = 0; i < position.length; i++) {\n            const piece = position.charAt(i);\n            if (piece === '/') {\n                square += 8;\n            }\n            else if (isDigit(piece)) {\n                square += parseInt(piece, 10);\n            }\n            else {\n                const color = piece < 'a' ? WHITE : BLACK;\n                this._put({ type: piece.toLowerCase(), color }, algebraic(square));\n                square++;\n            }\n        }\n        this._turn = tokens[1];\n        if (tokens[2].indexOf('K') > -1) {\n            this._castling.w |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('Q') > -1) {\n            this._castling.w |= BITS.QSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('k') > -1) {\n            this._castling.b |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('q') > -1) {\n            this._castling.b |= BITS.QSIDE_CASTLE;\n        }\n        this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n        this._halfMoves = parseInt(tokens[4], 10);\n        this._moveNumber = parseInt(tokens[5], 10);\n        this._updateSetup(fen);\n        this._incPositionCount(fen);\n    }\n    fen() {\n        let empty = 0;\n        let fen = '';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i]) {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                const { color, type: piece } = this._board[i];\n                fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n            }\n            else {\n                empty++;\n            }\n            if ((i + 1) & 0x88) {\n                if (empty > 0) {\n                    fen += empty;\n                }\n                if (i !== Ox88.h1) {\n                    fen += '/';\n                }\n                empty = 0;\n                i += 8;\n            }\n        }\n        let castling = '';\n        if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n            castling += 'K';\n        }\n        if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n            castling += 'Q';\n        }\n        if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n            castling += 'k';\n        }\n        if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n            castling += 'q';\n        }\n        // do we have an empty castling flag?\n        castling = castling || '-';\n        let epSquare = '-';\n        /*\n         * only print the ep square if en passant is a valid move (pawn is present\n         * and ep capture is not pinned)\n         */\n        if (this._epSquare !== EMPTY) {\n            const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n            const squares = [bigPawnSquare + 1, bigPawnSquare - 1];\n            for (const square of squares) {\n                // is the square off the board?\n                if (square & 0x88) {\n                    continue;\n                }\n                const color = this._turn;\n                // is there a pawn that can capture the epSquare?\n                if (this._board[square]?.color === color &&\n                    this._board[square]?.type === PAWN) {\n                    // if the pawn makes an ep capture, does it leave it's king in check?\n                    this._makeMove({\n                        color,\n                        from: square,\n                        to: this._epSquare,\n                        piece: PAWN,\n                        captured: PAWN,\n                        flags: BITS.EP_CAPTURE,\n                    });\n                    const isLegal = !this._isKingAttacked(color);\n                    this._undoMove();\n                    // if ep is legal, break and set the ep square in the FEN output\n                    if (isLegal) {\n                        epSquare = algebraic(this._epSquare);\n                        break;\n                    }\n                }\n            }\n        }\n        return [\n            fen,\n            this._turn,\n            castling,\n            epSquare,\n            this._halfMoves,\n            this._moveNumber,\n        ].join(' ');\n    }\n    /*\n     * Called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object. If the FEN\n     * is equal to the default position, the SetUp and FEN are deleted the setup\n     * is only updated if history.length is zero, ie moves haven't been made.\n     */\n    _updateSetup(fen) {\n        if (this._history.length > 0)\n            return;\n        if (fen !== DEFAULT_POSITION) {\n            this._header['SetUp'] = '1';\n            this._header['FEN'] = fen;\n        }\n        else {\n            delete this._header['SetUp'];\n            delete this._header['FEN'];\n        }\n    }\n    reset() {\n        this.load(DEFAULT_POSITION);\n    }\n    get(square) {\n        return this._board[Ox88[square]] || false;\n    }\n    put({ type, color }, square) {\n        if (this._put({ type, color }, square)) {\n            this._updateCastlingRights();\n            this._updateEnPassantSquare();\n            this._updateSetup(this.fen());\n            return true;\n        }\n        return false;\n    }\n    _put({ type, color }, square) {\n        // check for piece\n        if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n            return false;\n        }\n        // check for valid square\n        if (!(square in Ox88)) {\n            return false;\n        }\n        const sq = Ox88[square];\n        // don't let the user place more than one king\n        if (type == KING &&\n            !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n            return false;\n        }\n        const currentPieceOnSquare = this._board[sq];\n        // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`\n        if (currentPieceOnSquare && currentPieceOnSquare.type === KING) {\n            this._kings[currentPieceOnSquare.color] = EMPTY;\n        }\n        this._board[sq] = { type: type, color: color };\n        if (type === KING) {\n            this._kings[color] = sq;\n        }\n        return true;\n    }\n    remove(square) {\n        const piece = this.get(square);\n        delete this._board[Ox88[square]];\n        if (piece && piece.type === KING) {\n            this._kings[piece.color] = EMPTY;\n        }\n        this._updateCastlingRights();\n        this._updateEnPassantSquare();\n        this._updateSetup(this.fen());\n        return piece;\n    }\n    _updateCastlingRights() {\n        const whiteKingInPlace = this._board[Ox88.e1]?.type === KING &&\n            this._board[Ox88.e1]?.color === WHITE;\n        const blackKingInPlace = this._board[Ox88.e8]?.type === KING &&\n            this._board[Ox88.e8]?.color === BLACK;\n        if (!whiteKingInPlace ||\n            this._board[Ox88.a1]?.type !== ROOK ||\n            this._board[Ox88.a1]?.color !== WHITE) {\n            this._castling.w &= ~BITS.QSIDE_CASTLE;\n        }\n        if (!whiteKingInPlace ||\n            this._board[Ox88.h1]?.type !== ROOK ||\n            this._board[Ox88.h1]?.color !== WHITE) {\n            this._castling.w &= ~BITS.KSIDE_CASTLE;\n        }\n        if (!blackKingInPlace ||\n            this._board[Ox88.a8]?.type !== ROOK ||\n            this._board[Ox88.a8]?.color !== BLACK) {\n            this._castling.b &= ~BITS.QSIDE_CASTLE;\n        }\n        if (!blackKingInPlace ||\n            this._board[Ox88.h8]?.type !== ROOK ||\n            this._board[Ox88.h8]?.color !== BLACK) {\n            this._castling.b &= ~BITS.KSIDE_CASTLE;\n        }\n    }\n    _updateEnPassantSquare() {\n        if (this._epSquare === EMPTY) {\n            return;\n        }\n        const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16);\n        const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n        const attackers = [currentSquare + 1, currentSquare - 1];\n        if (this._board[startSquare] !== null ||\n            this._board[this._epSquare] !== null ||\n            this._board[currentSquare]?.color !== swapColor(this._turn) ||\n            this._board[currentSquare]?.type !== PAWN) {\n            this._epSquare = EMPTY;\n            return;\n        }\n        const canCapture = (square) => !(square & 0x88) &&\n            this._board[square]?.color === this._turn &&\n            this._board[square]?.type === PAWN;\n        if (!attackers.some(canCapture)) {\n            this._epSquare = EMPTY;\n        }\n    }\n    _attacked(color, square) {\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            // if empty square or wrong color\n            if (this._board[i] === undefined || this._board[i].color !== color) {\n                continue;\n            }\n            const piece = this._board[i];\n            const difference = i - square;\n            // skip - to/from square are the same\n            if (difference === 0) {\n                continue;\n            }\n            const index = difference + 119;\n            if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n                if (piece.type === PAWN) {\n                    if (difference > 0) {\n                        if (piece.color === WHITE)\n                            return true;\n                    }\n                    else {\n                        if (piece.color === BLACK)\n                            return true;\n                    }\n                    continue;\n                }\n                // if the piece is a knight or a king\n                if (piece.type === 'n' || piece.type === 'k')\n                    return true;\n                const offset = RAYS[index];\n                let j = i + offset;\n                let blocked = false;\n                while (j !== square) {\n                    if (this._board[j] != null) {\n                        blocked = true;\n                        break;\n                    }\n                    j += offset;\n                }\n                if (!blocked)\n                    return true;\n            }\n        }\n        return false;\n    }\n    _isKingAttacked(color) {\n        const square = this._kings[color];\n        return square === -1 ? false : this._attacked(swapColor(color), square);\n    }\n    isAttacked(square, attackedBy) {\n        return this._attacked(attackedBy, Ox88[square]);\n    }\n    isCheck() {\n        return this._isKingAttacked(this._turn);\n    }\n    inCheck() {\n        return this.isCheck();\n    }\n    isCheckmate() {\n        return this.isCheck() && this._moves().length === 0;\n    }\n    isStalemate() {\n        return !this.isCheck() && this._moves().length === 0;\n    }\n    isInsufficientMaterial() {\n        /*\n         * k.b. vs k.b. (of opposite colors) with mate in 1:\n         * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n         *\n         * k.b. vs k.n. with mate in 1:\n         * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n         */\n        const pieces = {\n            b: 0,\n            n: 0,\n            r: 0,\n            q: 0,\n            k: 0,\n            p: 0,\n        };\n        const bishops = [];\n        let numPieces = 0;\n        let squareColor = 0;\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            squareColor = (squareColor + 1) % 2;\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            const piece = this._board[i];\n            if (piece) {\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n                if (piece.type === BISHOP) {\n                    bishops.push(squareColor);\n                }\n                numPieces++;\n            }\n        }\n        // k vs. k\n        if (numPieces === 2) {\n            return true;\n        }\n        else if (\n        // k vs. kn .... or .... k vs. kb\n        numPieces === 3 &&\n            (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n            return true;\n        }\n        else if (numPieces === pieces[BISHOP] + 2) {\n            // kb vs. kb where any number of bishops are all on the same color\n            let sum = 0;\n            const len = bishops.length;\n            for (let i = 0; i < len; i++) {\n                sum += bishops[i];\n            }\n            if (sum === 0 || sum === len) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isThreefoldRepetition() {\n        return this._getPositionCount(this.fen()) >= 3;\n    }\n    isDraw() {\n        return (this._halfMoves >= 100 || // 50 moves per side = 100 half moves\n            this.isStalemate() ||\n            this.isInsufficientMaterial() ||\n            this.isThreefoldRepetition());\n    }\n    isGameOver() {\n        return this.isCheckmate() || this.isStalemate() || this.isDraw();\n    }\n    moves({ verbose = false, square = undefined, piece = undefined, } = {}) {\n        const moves = this._moves({ square, piece });\n        if (verbose) {\n            return moves.map((move) => this._makePretty(move));\n        }\n        else {\n            return moves.map((move) => this._moveToSan(move, moves));\n        }\n    }\n    _moves({ legal = true, piece = undefined, square = undefined, } = {}) {\n        const forSquare = square ? square.toLowerCase() : undefined;\n        const forPiece = piece?.toLowerCase();\n        const moves = [];\n        const us = this._turn;\n        const them = swapColor(us);\n        let firstSquare = Ox88.a8;\n        let lastSquare = Ox88.h1;\n        let singleSquare = false;\n        // are we generating moves for a single square?\n        if (forSquare) {\n            // illegal square, return empty moves\n            if (!(forSquare in Ox88)) {\n                return [];\n            }\n            else {\n                firstSquare = lastSquare = Ox88[forSquare];\n                singleSquare = true;\n            }\n        }\n        for (let from = firstSquare; from <= lastSquare; from++) {\n            // did we run off the end of the board\n            if (from & 0x88) {\n                from += 7;\n                continue;\n            }\n            // empty square or opponent, skip\n            if (!this._board[from] || this._board[from].color === them) {\n                continue;\n            }\n            const { type } = this._board[from];\n            let to;\n            if (type === PAWN) {\n                if (forPiece && forPiece !== type)\n                    continue;\n                // single square, non-capturing\n                to = from + PAWN_OFFSETS[us][0];\n                if (!this._board[to]) {\n                    addMove(moves, us, from, to, PAWN);\n                    // double square\n                    to = from + PAWN_OFFSETS[us][1];\n                    if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n                        addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN);\n                    }\n                }\n                // pawn captures\n                for (let j = 2; j < 4; j++) {\n                    to = from + PAWN_OFFSETS[us][j];\n                    if (to & 0x88)\n                        continue;\n                    if (this._board[to]?.color === them) {\n                        addMove(moves, us, from, to, PAWN, this._board[to].type, BITS.CAPTURE);\n                    }\n                    else if (to === this._epSquare) {\n                        addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE);\n                    }\n                }\n            }\n            else {\n                if (forPiece && forPiece !== type)\n                    continue;\n                for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n                    const offset = PIECE_OFFSETS[type][j];\n                    to = from;\n                    while (true) {\n                        to += offset;\n                        if (to & 0x88)\n                            break;\n                        if (!this._board[to]) {\n                            addMove(moves, us, from, to, type);\n                        }\n                        else {\n                            // own color, stop loop\n                            if (this._board[to].color === us)\n                                break;\n                            addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n                            break;\n                        }\n                        /* break, if knight or king */\n                        if (type === KNIGHT || type === KING)\n                            break;\n                    }\n                }\n            }\n        }\n        /*\n         * check for castling if we're:\n         *   a) generating all moves, or\n         *   b) doing single square move generation on the king's square\n         */\n        if (forPiece === undefined || forPiece === KING) {\n            if (!singleSquare || lastSquare === this._kings[us]) {\n                // king-side castling\n                if (this._castling[us] & BITS.KSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom + 2;\n                    if (!this._board[castlingFrom + 1] &&\n                        !this._board[castlingTo] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom + 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.KSIDE_CASTLE);\n                    }\n                }\n                // queen-side castling\n                if (this._castling[us] & BITS.QSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom - 2;\n                    if (!this._board[castlingFrom - 1] &&\n                        !this._board[castlingFrom - 2] &&\n                        !this._board[castlingFrom - 3] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom - 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.QSIDE_CASTLE);\n                    }\n                }\n            }\n        }\n        /*\n         * return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured)\n         */\n        if (!legal || this._kings[us] === -1) {\n            return moves;\n        }\n        // filter out illegal moves\n        const legalMoves = [];\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(us)) {\n                legalMoves.push(moves[i]);\n            }\n            this._undoMove();\n        }\n        return legalMoves;\n    }\n    move(move, { strict = false } = {}) {\n        /*\n         * The move function can be called with in the following parameters:\n         *\n         * .move('Nxb7')       <- argument is a case-sensitive SAN string\n         *\n         * .move({ from: 'h7', <- argument is a move object\n         *         to :'h8',\n         *         promotion: 'q' })\n         *\n         *\n         * An optional strict argument may be supplied to tell chess.js to\n         * strictly follow the SAN specification.\n         */\n        let moveObj = null;\n        if (typeof move === 'string') {\n            moveObj = this._moveFromSan(move, strict);\n        }\n        else if (typeof move === 'object') {\n            const moves = this._moves();\n            // convert the pretty move object to an ugly move object\n            for (let i = 0, len = moves.length; i < len; i++) {\n                if (move.from === algebraic(moves[i].from) &&\n                    move.to === algebraic(moves[i].to) &&\n                    (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n                    moveObj = moves[i];\n                    break;\n                }\n            }\n        }\n        // failed to find move\n        if (!moveObj) {\n            if (typeof move === 'string') {\n                throw new Error(`Invalid move: ${move}`);\n            }\n            else {\n                throw new Error(`Invalid move: ${JSON.stringify(move)}`);\n            }\n        }\n        /*\n         * need to make a copy of move because we can't generate SAN after the move\n         * is made\n         */\n        const prettyMove = this._makePretty(moveObj);\n        this._makeMove(moveObj);\n        this._incPositionCount(prettyMove.after);\n        return prettyMove;\n    }\n    _push(move) {\n        this._history.push({\n            move,\n            kings: { b: this._kings.b, w: this._kings.w },\n            turn: this._turn,\n            castling: { b: this._castling.b, w: this._castling.w },\n            epSquare: this._epSquare,\n            halfMoves: this._halfMoves,\n            moveNumber: this._moveNumber,\n        });\n    }\n    _makeMove(move) {\n        const us = this._turn;\n        const them = swapColor(us);\n        this._push(move);\n        this._board[move.to] = this._board[move.from];\n        delete this._board[move.from];\n        // if ep capture, remove the captured pawn\n        if (move.flags & BITS.EP_CAPTURE) {\n            if (this._turn === BLACK) {\n                delete this._board[move.to - 16];\n            }\n            else {\n                delete this._board[move.to + 16];\n            }\n        }\n        // if pawn promotion, replace with new piece\n        if (move.promotion) {\n            this._board[move.to] = { type: move.promotion, color: us };\n        }\n        // if we moved the king\n        if (this._board[move.to].type === KING) {\n            this._kings[us] = move.to;\n            // if we castled, move the rook next to the king\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                const castlingTo = move.to - 1;\n                const castlingFrom = move.to + 1;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            else if (move.flags & BITS.QSIDE_CASTLE) {\n                const castlingTo = move.to + 1;\n                const castlingFrom = move.to - 2;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            // turn off castling\n            this._castling[us] = 0;\n        }\n        // turn off castling if we move a rook\n        if (this._castling[us]) {\n            for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n                if (move.from === ROOKS[us][i].square &&\n                    this._castling[us] & ROOKS[us][i].flag) {\n                    this._castling[us] ^= ROOKS[us][i].flag;\n                    break;\n                }\n            }\n        }\n        // turn off castling if we capture a rook\n        if (this._castling[them]) {\n            for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n                if (move.to === ROOKS[them][i].square &&\n                    this._castling[them] & ROOKS[them][i].flag) {\n                    this._castling[them] ^= ROOKS[them][i].flag;\n                    break;\n                }\n            }\n        }\n        // if big pawn move, update the en passant square\n        if (move.flags & BITS.BIG_PAWN) {\n            if (us === BLACK) {\n                this._epSquare = move.to - 16;\n            }\n            else {\n                this._epSquare = move.to + 16;\n            }\n        }\n        else {\n            this._epSquare = EMPTY;\n        }\n        // reset the 50 move counter if a pawn is moved or a piece is captured\n        if (move.piece === PAWN) {\n            this._halfMoves = 0;\n        }\n        else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n            this._halfMoves = 0;\n        }\n        else {\n            this._halfMoves++;\n        }\n        if (us === BLACK) {\n            this._moveNumber++;\n        }\n        this._turn = them;\n    }\n    undo() {\n        const move = this._undoMove();\n        if (move) {\n            const prettyMove = this._makePretty(move);\n            this._decPositionCount(prettyMove.after);\n            return prettyMove;\n        }\n        return null;\n    }\n    _undoMove() {\n        const old = this._history.pop();\n        if (old === undefined) {\n            return null;\n        }\n        const move = old.move;\n        this._kings = old.kings;\n        this._turn = old.turn;\n        this._castling = old.castling;\n        this._epSquare = old.epSquare;\n        this._halfMoves = old.halfMoves;\n        this._moveNumber = old.moveNumber;\n        const us = this._turn;\n        const them = swapColor(us);\n        this._board[move.from] = this._board[move.to];\n        this._board[move.from].type = move.piece; // to undo any promotions\n        delete this._board[move.to];\n        if (move.captured) {\n            if (move.flags & BITS.EP_CAPTURE) {\n                // en passant capture\n                let index;\n                if (us === BLACK) {\n                    index = move.to - 16;\n                }\n                else {\n                    index = move.to + 16;\n                }\n                this._board[index] = { type: PAWN, color: them };\n            }\n            else {\n                // regular capture\n                this._board[move.to] = { type: move.captured, color: them };\n            }\n        }\n        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n            let castlingTo, castlingFrom;\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                castlingTo = move.to + 1;\n                castlingFrom = move.to - 1;\n            }\n            else {\n                castlingTo = move.to - 2;\n                castlingFrom = move.to + 1;\n            }\n            this._board[castlingTo] = this._board[castlingFrom];\n            delete this._board[castlingFrom];\n        }\n        return move;\n    }\n    pgn({ newline = '\\n', maxWidth = 0, } = {}) {\n        /*\n         * using the specification from http://www.chessclub.com/help/PGN-spec\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n         */\n        const result = [];\n        let headerExists = false;\n        /* add the PGN header information */\n        for (const i in this._header) {\n            /*\n             * TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             */\n            result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline);\n            headerExists = true;\n        }\n        if (headerExists && this._history.length) {\n            result.push(newline);\n        }\n        const appendComment = (moveString) => {\n            const comment = this._comments[this.fen()];\n            if (typeof comment !== 'undefined') {\n                const delimiter = moveString.length > 0 ? ' ' : '';\n                moveString = `${moveString}${delimiter}{${comment}}`;\n            }\n            return moveString;\n        };\n        // pop all of history onto reversed_history\n        const reversedHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        const moves = [];\n        let moveString = '';\n        // special case of a commented starting position with no moves\n        if (reversedHistory.length === 0) {\n            moves.push(appendComment(''));\n        }\n        // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n        while (reversedHistory.length > 0) {\n            moveString = appendComment(moveString);\n            const move = reversedHistory.pop();\n            // make TypeScript stop complaining about move being undefined\n            if (!move) {\n                break;\n            }\n            // if the position started with black to move, start PGN with #. ...\n            if (!this._history.length && move.color === 'b') {\n                const prefix = `${this._moveNumber}. ...`;\n                // is there a comment preceding the first move?\n                moveString = moveString ? `${moveString} ${prefix}` : prefix;\n            }\n            else if (move.color === 'w') {\n                // store the previous generated move_string if we have one\n                if (moveString.length) {\n                    moves.push(moveString);\n                }\n                moveString = this._moveNumber + '.';\n            }\n            moveString =\n                moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }));\n            this._makeMove(move);\n        }\n        // are there any other leftover moves?\n        if (moveString.length) {\n            moves.push(appendComment(moveString));\n        }\n        // is there a result?\n        if (typeof this._header.Result !== 'undefined') {\n            moves.push(this._header.Result);\n        }\n        /*\n         * history should be back to what it was before we started generating PGN,\n         * so join together moves\n         */\n        if (maxWidth === 0) {\n            return result.join('') + moves.join(' ');\n        }\n        // TODO (jah): huh?\n        const strip = function () {\n            if (result.length > 0 && result[result.length - 1] === ' ') {\n                result.pop();\n                return true;\n            }\n            return false;\n        };\n        // NB: this does not preserve comment whitespace.\n        const wrapComment = function (width, move) {\n            for (const token of move.split(' ')) {\n                if (!token) {\n                    continue;\n                }\n                if (width + token.length > maxWidth) {\n                    while (strip()) {\n                        width--;\n                    }\n                    result.push(newline);\n                    width = 0;\n                }\n                result.push(token);\n                width += token.length;\n                result.push(' ');\n                width++;\n            }\n            if (strip()) {\n                width--;\n            }\n            return width;\n        };\n        // wrap the PGN output at max_width\n        let currentWidth = 0;\n        for (let i = 0; i < moves.length; i++) {\n            if (currentWidth + moves[i].length > maxWidth) {\n                if (moves[i].includes('{')) {\n                    currentWidth = wrapComment(currentWidth, moves[i]);\n                    continue;\n                }\n            }\n            // if the current move will push past max_width\n            if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n                // don't end the line with whitespace\n                if (result[result.length - 1] === ' ') {\n                    result.pop();\n                }\n                result.push(newline);\n                currentWidth = 0;\n            }\n            else if (i !== 0) {\n                result.push(' ');\n                currentWidth++;\n            }\n            result.push(moves[i]);\n            currentWidth += moves[i].length;\n        }\n        return result.join('');\n    }\n    header(...args) {\n        for (let i = 0; i < args.length; i += 2) {\n            if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n                this._header[args[i]] = args[i + 1];\n            }\n        }\n        return this._header;\n    }\n    loadPgn(pgn, { strict = false, newlineChar = '\\r?\\n', } = {}) {\n        function mask(str) {\n            return str.replace(/\\\\/g, '\\\\');\n        }\n        function parsePgnHeader(header) {\n            const headerObj = {};\n            const headers = header.split(new RegExp(mask(newlineChar)));\n            let key = '';\n            let value = '';\n            for (let i = 0; i < headers.length; i++) {\n                const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n                key = headers[i].replace(regex, '$1');\n                value = headers[i].replace(regex, '$2');\n                if (key.trim().length > 0) {\n                    headerObj[key] = value;\n                }\n            }\n            return headerObj;\n        }\n        // strip whitespace from head/tail of PGN block\n        pgn = pgn.trim();\n        /*\n         * RegExp to split header. Takes advantage of the fact that header and movetext\n         * will always have a blank line between them (ie, two newline_char's). Handles\n         * case where movetext is empty by matching newlineChar until end of string is\n         * matched - effectively trimming from the end extra newlineChar.\n         *\n         * With default newline_char, will equal:\n         * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n         */\n        const headerRegex = new RegExp('^(\\\\[((?:' +\n            mask(newlineChar) +\n            ')|.)*\\\\])' +\n            '((?:\\\\s*' +\n            mask(newlineChar) +\n            '){2}|(?:\\\\s*' +\n            mask(newlineChar) +\n            ')*$)');\n        // If no header given, begin with moves.\n        const headerRegexResults = headerRegex.exec(pgn);\n        const headerString = headerRegexResults\n            ? headerRegexResults.length >= 2\n                ? headerRegexResults[1]\n                : ''\n            : '';\n        // Put the board in the starting position\n        this.reset();\n        // parse PGN header\n        const headers = parsePgnHeader(headerString);\n        let fen = '';\n        for (const key in headers) {\n            // check to see user is including fen (possibly with wrong tag case)\n            if (key.toLowerCase() === 'fen') {\n                fen = headers[key];\n            }\n            this.header(key, headers[key]);\n        }\n        /*\n         * the permissive parser should attempt to load a fen tag, even if it's the\n         * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n         */\n        if (!strict) {\n            if (fen) {\n                this.load(fen, { preserveHeaders: true });\n            }\n        }\n        else {\n            /*\n             * strict parser - load the starting position indicated by [Setup '1']\n             * and [FEN position]\n             */\n            if (headers['SetUp'] === '1') {\n                if (!('FEN' in headers)) {\n                    throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');\n                }\n                // don't clear the headers when loading\n                this.load(headers['FEN'], { preserveHeaders: true });\n            }\n        }\n        /*\n         * NB: the regexes below that delete move numbers, recursive annotations,\n         * and numeric annotation glyphs may also match text in comments. To\n         * prevent this, we transform comments by hex-encoding them in place and\n         * decoding them again after the other tokens have been deleted.\n         *\n         * While the spec states that PGN files should be ASCII encoded, we use\n         * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n         * for modern users\n         */\n        function toHex(s) {\n            return Array.from(s)\n                .map(function (c) {\n                /*\n                 * encodeURI doesn't transform most ASCII characters, so we handle\n                 * these ourselves\n                 */\n                return c.charCodeAt(0) < 128\n                    ? c.charCodeAt(0).toString(16)\n                    : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\n            })\n                .join('');\n        }\n        function fromHex(s) {\n            return s.length == 0\n                ? ''\n                : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));\n        }\n        const encodeComment = function (s) {\n            s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');\n            return `{${toHex(s.slice(1, s.length - 1))}}`;\n        };\n        const decodeComment = function (s) {\n            if (s.startsWith('{') && s.endsWith('}')) {\n                return fromHex(s.slice(1, s.length - 1));\n            }\n        };\n        // delete header to get the moves\n        let ms = pgn\n            .replace(headerString, '')\n            .replace(\n        // encode comments so they don't get deleted below\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'), function (_match, bracket, semicolon) {\n            return bracket !== undefined\n                ? encodeComment(bracket)\n                : ' ' + encodeComment(`{${semicolon.slice(1)}}`);\n        })\n            .replace(new RegExp(mask(newlineChar), 'g'), ' ');\n        // delete recursive annotation variations\n        const ravRegex = /(\\([^()]+\\))+?/g;\n        while (ravRegex.test(ms)) {\n            ms = ms.replace(ravRegex, '');\n        }\n        // delete move numbers\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n        // delete ... indicating black to move\n        ms = ms.replace(/\\.\\.\\./g, '');\n        /* delete numeric annotation glyphs */\n        ms = ms.replace(/\\$\\d+/g, '');\n        // trim and get array of moves\n        let moves = ms.trim().split(new RegExp(/\\s+/));\n        // delete empty entries\n        moves = moves.filter((move) => move !== '');\n        let result = '';\n        for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n            const comment = decodeComment(moves[halfMove]);\n            if (comment !== undefined) {\n                this._comments[this.fen()] = comment;\n                continue;\n            }\n            const move = this._moveFromSan(moves[halfMove], strict);\n            // invalid move\n            if (move == null) {\n                // was the move an end of game marker\n                if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n                    result = moves[halfMove];\n                }\n                else {\n                    throw new Error(`Invalid move in PGN: ${moves[halfMove]}`);\n                }\n            }\n            else {\n                // reset the end of game marker if making a valid move\n                result = '';\n                this._makeMove(move);\n                this._incPositionCount(this.fen());\n            }\n        }\n        /*\n         * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n         * the termination marker. Only do this when headers are present, but the\n         * result tag is missing\n         */\n        if (result && Object.keys(this._header).length && !this._header['Result']) {\n            this.header('Result', result);\n        }\n    }\n    /*\n     * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n     * (SAN)\n     *\n     * @param {boolean} strict Use the strict SAN parser. It will throw errors\n     * on overly disambiguated moves (see below):\n     *\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n     * 4. ... Ne7 is technically the valid SAN\n     */\n    _moveToSan(move, moves) {\n        let output = '';\n        if (move.flags & BITS.KSIDE_CASTLE) {\n            output = 'O-O';\n        }\n        else if (move.flags & BITS.QSIDE_CASTLE) {\n            output = 'O-O-O';\n        }\n        else {\n            if (move.piece !== PAWN) {\n                const disambiguator = getDisambiguator(move, moves);\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n                if (move.piece === PAWN) {\n                    output += algebraic(move.from)[0];\n                }\n                output += 'x';\n            }\n            output += algebraic(move.to);\n            if (move.promotion) {\n                output += '=' + move.promotion.toUpperCase();\n            }\n        }\n        this._makeMove(move);\n        if (this.isCheck()) {\n            if (this.isCheckmate()) {\n                output += '#';\n            }\n            else {\n                output += '+';\n            }\n        }\n        this._undoMove();\n        return output;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    _moveFromSan(move, strict = false) {\n        // strip off any move decorations: e.g Nf3+?! becomes Nf3\n        const cleanMove = strippedSan(move);\n        let pieceType = inferPieceType(cleanMove);\n        let moves = this._moves({ legal: true, piece: pieceType });\n        // strict parser\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n                return moves[i];\n            }\n        }\n        // the strict parser failed\n        if (strict) {\n            return null;\n        }\n        let piece = undefined;\n        let matches = undefined;\n        let from = undefined;\n        let to = undefined;\n        let promotion = undefined;\n        /*\n         * The default permissive (non-strict) parser allows the user to parse\n         * non-standard chess notations. This parser is only run after the strict\n         * Standard Algebraic Notation (SAN) parser has failed.\n         *\n         * When running the permissive parser, we'll run a regex to grab the piece, the\n         * to/from square, and an optional promotion piece. This regex will\n         * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n         * f7f8q, b1c3\n         *\n         * NOTE: Some positions and moves may be ambiguous when using the permissive\n         * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n         * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n         * move). In these cases, the permissive parser will default to the most\n         * basic interpretation (which is b1c3 parsing to Nc3).\n         */\n        let overlyDisambiguated = false;\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n        if (matches) {\n            piece = matches[1];\n            from = matches[2];\n            to = matches[3];\n            promotion = matches[4];\n            if (from.length == 1) {\n                overlyDisambiguated = true;\n            }\n        }\n        else {\n            /*\n             * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n             * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n             * there is one legal knight move to e7). In this case, the value of\n             * 'from' variable will be a rank or file, not a square.\n             */\n            matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n                if (from.length == 1) {\n                    overlyDisambiguated = true;\n                }\n            }\n        }\n        pieceType = inferPieceType(cleanMove);\n        moves = this._moves({\n            legal: true,\n            piece: piece ? piece : pieceType,\n        });\n        if (!to) {\n            return null;\n        }\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (!from) {\n                // if there is no from square, it could be just 'x' missing from a capture\n                if (cleanMove ===\n                    strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')) {\n                    return moves[i];\n                }\n                // hand-compare move properties with the results from our permissive regex\n            }\n            else if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                Ox88[from] == moves[i].from &&\n                Ox88[to] == moves[i].to &&\n                (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                return moves[i];\n            }\n            else if (overlyDisambiguated) {\n                /*\n                 * SPECIAL CASE: we parsed a move string that may have an unneeded\n                 * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n                 */\n                const square = algebraic(moves[i].from);\n                if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                    Ox88[to] == moves[i].to &&\n                    (from == square[0] || from == square[1]) &&\n                    (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                    return moves[i];\n                }\n            }\n        }\n        return null;\n    }\n    ascii() {\n        let s = '   +------------------------+\\n';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // display the rank\n            if (file(i) === 0) {\n                s += ' ' + '87654321'[rank(i)] + ' |';\n            }\n            if (this._board[i]) {\n                const piece = this._board[i].type;\n                const color = this._board[i].color;\n                const symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n                s += ' ' + symbol + ' ';\n            }\n            else {\n                s += ' . ';\n            }\n            if ((i + 1) & 0x88) {\n                s += '|\\n';\n                i += 8;\n            }\n        }\n        s += '   +------------------------+\\n';\n        s += '     a  b  c  d  e  f  g  h';\n        return s;\n    }\n    perft(depth) {\n        const moves = this._moves({ legal: false });\n        let nodes = 0;\n        const color = this._turn;\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(color)) {\n                if (depth - 1 > 0) {\n                    nodes += this.perft(depth - 1);\n                }\n                else {\n                    nodes++;\n                }\n            }\n            this._undoMove();\n        }\n        return nodes;\n    }\n    // pretty = external move object\n    _makePretty(uglyMove) {\n        const { color, piece, from, to, flags, captured, promotion } = uglyMove;\n        let prettyFlags = '';\n        for (const flag in BITS) {\n            if (BITS[flag] & flags) {\n                prettyFlags += FLAGS[flag];\n            }\n        }\n        const fromAlgebraic = algebraic(from);\n        const toAlgebraic = algebraic(to);\n        const move = {\n            color,\n            piece,\n            from: fromAlgebraic,\n            to: toAlgebraic,\n            san: this._moveToSan(uglyMove, this._moves({ legal: true })),\n            flags: prettyFlags,\n            lan: fromAlgebraic + toAlgebraic,\n            before: this.fen(),\n            after: '',\n        };\n        // generate the FEN for the 'after' key\n        this._makeMove(uglyMove);\n        move.after = this.fen();\n        this._undoMove();\n        if (captured) {\n            move.captured = captured;\n        }\n        if (promotion) {\n            move.promotion = promotion;\n            move.lan += promotion;\n        }\n        return move;\n    }\n    turn() {\n        return this._turn;\n    }\n    board() {\n        const output = [];\n        let row = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i] == null) {\n                row.push(null);\n            }\n            else {\n                row.push({\n                    square: algebraic(i),\n                    type: this._board[i].type,\n                    color: this._board[i].color,\n                });\n            }\n            if ((i + 1) & 0x88) {\n                output.push(row);\n                row = [];\n                i += 8;\n            }\n        }\n        return output;\n    }\n    squareColor(square) {\n        if (square in Ox88) {\n            const sq = Ox88[square];\n            return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n        }\n        return null;\n    }\n    history({ verbose = false } = {}) {\n        const reversedHistory = [];\n        const moveHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            if (verbose) {\n                moveHistory.push(this._makePretty(move));\n            }\n            else {\n                moveHistory.push(this._moveToSan(move, this._moves()));\n            }\n            this._makeMove(move);\n        }\n        return moveHistory;\n    }\n    /*\n     * Keeps track of position occurrence counts for the purpose of repetition\n     * checking. All three methods (`_inc`, `_dec`, and `_get`) trim the\n     * irrelevent information from the fen, initialising new positions, and\n     * removing old positions from the record if their counts are reduced to 0.\n     */\n    _getPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        return this._positionCount[trimmedFen] || 0;\n    }\n    _incPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        if (this._positionCount[trimmedFen] === undefined) {\n            this._positionCount[trimmedFen] = 0;\n        }\n        this._positionCount[trimmedFen] += 1;\n    }\n    _decPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        if (this._positionCount[trimmedFen] === 1) {\n            delete this._positionCount[trimmedFen];\n        }\n        else {\n            this._positionCount[trimmedFen] -= 1;\n        }\n    }\n    _pruneComments() {\n        const reversedHistory = [];\n        const currentComments = {};\n        const copyComment = (fen) => {\n            if (fen in this._comments) {\n                currentComments[fen] = this._comments[fen];\n            }\n        };\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        copyComment(this.fen());\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            this._makeMove(move);\n            copyComment(this.fen());\n        }\n        this._comments = currentComments;\n    }\n    getComment() {\n        return this._comments[this.fen()];\n    }\n    setComment(comment) {\n        this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n    }\n    deleteComment() {\n        const comment = this._comments[this.fen()];\n        delete this._comments[this.fen()];\n        return comment;\n    }\n    getComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            return { fen: fen, comment: this._comments[fen] };\n        });\n    }\n    deleteComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            const comment = this._comments[fen];\n            delete this._comments[fen];\n            return { fen: fen, comment: comment };\n        });\n    }\n    setCastlingRights(color, rights) {\n        for (const side of [KING, QUEEN]) {\n            if (rights[side] !== undefined) {\n                if (rights[side]) {\n                    this._castling[color] |= SIDES[side];\n                }\n                else {\n                    this._castling[color] &= ~SIDES[side];\n                }\n            }\n        }\n        this._updateCastlingRights();\n        const result = this.getCastlingRights(color);\n        return ((rights[KING] === undefined || rights[KING] === result[KING]) &&\n            (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN]));\n    }\n    getCastlingRights(color) {\n        return {\n            [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n            [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0,\n        };\n    }\n    moveNumber() {\n        return this._moveNumber;\n    }\n}\n//# sourceMappingURL=chess.js.map"],"names":["WHITE","BLACK","PAWN","KNIGHT","BISHOP","ROOK","QUEEN","KING","DEFAULT_POSITION","FLAGS","BITS","Ox88","PAWN_OFFSETS","PIECE_OFFSETS","ATTACKS","RAYS","PIECE_MASKS","SYMBOLS","PROMOTIONS","RANK_1","RANK_2","RANK_7","RANK_8","SIDES","ROOKS","SECOND_RANK","TERMINATION_MARKERS","rank","square","file","isDigit","c","algebraic","f","r","swapColor","color","validateFen","fen","tokens","moveNumber","halfMoves","rows","i","sumFields","previousWasNumber","k","kings","regex","char","getDisambiguator","move","moves","from","to","piece","ambiguities","sameRank","sameFile","len","ambigFrom","ambigTo","ambigPiece","addMove","captured","flags","promotion","inferPieceType","san","pieceType","strippedSan","trimFen","Chess","__publicField","preserveHeaders","key","skipValidation","adjustments","ok","error","position","_a","_b","empty","castling","epSquare","bigPawnSquare","squares","isLegal","type","sq","currentPieceOnSquare","_c","_d","_e","_f","_g","_h","_i","_j","_k","_l","whiteKingInPlace","blackKingInPlace","startSquare","currentSquare","attackers","canCapture","difference","index","offset","j","blocked","attackedBy","pieces","bishops","numPieces","squareColor","sum","verbose","legal","forSquare","forPiece","us","them","firstSquare","lastSquare","singleSquare","castlingFrom","castlingTo","legalMoves","strict","moveObj","prettyMove","old","newline","maxWidth","result","headerExists","appendComment","moveString","comment","delimiter","reversedHistory","prefix","strip","wrapComment","width","token","currentWidth","args","pgn","newlineChar","mask","str","parsePgnHeader","header","headerObj","headers","value","headerRegexResults","headerString","toHex","s","fromHex","encodeComment","decodeComment","ms","_match","bracket","semicolon","ravRegex","halfMove","output","disambiguator","cleanMove","matches","overlyDisambiguated","symbol","depth","nodes","uglyMove","prettyFlags","flag","fromAlgebraic","toAlgebraic","row","moveHistory","trimmedFen","currentComments","copyComment","rights","side"],"mappings":"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G,EAAG,EAAG,EAChD,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAChD,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAChD,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAChD,EAEMC,GAAO,CACT,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAChD,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAChD,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EACpD,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,IAAK,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACnD,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EACnD,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,EAAG,IAAK,EAAG,EAAG,IAAK,EAAG,EAAG,EAAG,EAAG,EACnD,EAAG,EAAG,EAAG,IAAK,EAAG,EAAG,EAAG,IA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","x_google_ignoreList":[0]}